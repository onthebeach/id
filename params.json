{"name":"Id","tagline":"Simple models based on hashes","body":"# id\r\n### simple models based on hashes\r\n\r\nJSON is a great way to transfer data between systems, and it's easy to parse into a Ruby hash. But sometimes it's nice to have actual methods to call when you want to get attributes from your data, rather than coupling your entire codebase to the hash representation by littering it with calls to `fetch` or `[]`. The same goes for BSON documents stored in Mongo.\r\n\r\nThat's where `id` (as in Freud) comes in. You define your model classes using syntax that should look pretty familiar if you've used any popular Ruby ORMs - but `id` is not an ORM. Model objects defined with `id` have a constructor that accepts a hash, and you define the values of this hash that are made readable as fields - but that hash can come from any source.\r\n\r\n#### Defining a model\r\n\r\nDefining a model looks like this:\r\n\r\n    class MyModel\r\n      include Id::Model\r\n\r\n      field :foo\r\n      field :bar, default: 42\r\n      field :baz, key: 'barry'\r\n\r\n    end\r\n\r\n    my_model = MyModel.new(foo: 7, barry: 'hello')\r\n    my_model.foo # => 7\r\n    my_model.bar # => 42\r\n    my_model.baz # => 'hello'\r\n\r\nAs you can see, you can specify default values as well as key aliases.\r\n\r\n#### Associations\r\n\r\nYou can specify has_one or has_many \"associations\" - what would be nested subdocuments in MongoDB for example - like this:\r\n\r\n    class Zoo\r\n      include Id::Model\r\n\r\n      has_many :lions\r\n      has_many :zebras\r\n      has_one :zookeeper, type: Person\r\n    end\r\n\r\n    zoo = Zoo.new(lions: [{name: 'Hetty'}],\r\n                  zebras: [{name: 'Lisa'}],\r\n                  zookeeper: {name: 'Russell'})\r\n\r\n    zoo.lions.first.class # => Lion\r\n    zoo.lions.first.name  # => \"Hetty\"\r\n    zoo.zookeeper.class   # => Person\r\n    zoo.zookeeper.name    # => \"Russell\"\r\n\r\nTypes are inferred from the association name unless one is specified.\r\n\r\n#### Compound Fields\r\n\r\nIt is sometimes useful to wrap some of the fields into another object. You can achieve this by using compound_field method like this:\r\n\r\n    class Address\r\n      include Id::Model\r\n\r\n      field :city\r\n      field :streeet\r\n    end\r\n\r\n    class Person\r\n      include Id::Model\r\n\r\n      field :name\r\n      field :city\r\n      field :strt\r\n\r\n      compound_field, :address, { city: \"city\", street: \"strt\" }, type: Address\r\n    end\r\n\r\n    person = Person.new(name: \"Radek\", city: \"MCR\", street: \"King's Street\")\r\n\r\n    person.address.class # => Address\r\n    person.address.street # => \"King's Street\"\r\n\r\n#### Designed for immutability\r\n\r\n`id` models provide accessor methods, but no mutator methods, because they are designed for immutability. How do immutable models work? When you need to change some field of a model object, a new copy of the object is created with the field changed as required. This is handled for you by `id`'s `set` method:\r\n\r\n    person = Person.new(name: 'Russell', job: 'programmer')\r\n    person.set(name: 'Radek') # => returns a new Person whose name is Radek  and whose job is 'programmer'\r\n\r\nYou can even set fields on nested models in this way:\r\n\r\n    person.hat.set(color: 'red') # => returns a new person object with a new hat object with its color set to red\r\n\r\n#### Avoiding nils\r\n\r\n`id` tries to avoid nils entirely, by using the Option pattern found in many functional programming languages and implemented [here](http://github.com/rsslldnphy/optional).\r\nJust mark optional fields as `optional: true` and their accessors will return either `Some[value]` or `None`.\r\n\r\n## Method Reference\r\n\r\n### class methods\r\n\r\n#### field(field_name, options={})\r\n\r\ncreate an access method on Id object instance\r\n\r\n##### options\r\n* _key_: fetch _key_ instead of field_name from data hash\r\n* _default_: set the default value\r\n* _optional_: if set to true - don't rise errors if the value is nil, return None if value is not nil return Some[value]\r\n* _type_: typecast the value (by default the values can be typecasted to: Money, Date, Time)\r\n\r\nExample:\r\n    \r\n    class Foo\r\n      include Id::Model\r\n      field :bar, default: \"baz\", key: \"qux\"\r\n      field :zyzzybalubah, optional: true\r\n      field :corge, type: Date\r\n    end\r\n    \r\n    foo = Foo.new()\r\n    foo.bar # => \"baz\"\r\n    foo.zyzzybalubah # => None\r\n    \r\n    foo = Foo.new(qux: \"quxx\", zyzzybalubah: \"Russell\", corge: \"1 Jan 2012\")\r\n    foo.bar # => \"quxx\"\r\n    foo.zyzzybalubah # => Some[\"Russell\"]\r\n    foo.corge.year # => 2012\r\n    foo.corge.class # => Date\r\n\r\n#### has_one(field_name, options={})\r\n\r\ncreate new has_one \"association\" field\r\n\r\n##### options\r\n* _key_: fetch _key_ instead of field_name from data hash\r\n* _optional_: if set to true - don't rise errors if the value is nil, return None if value is not nil return Some[value of specified type]\r\n* _type_: change type of returned value\r\n\r\nExample:\r\n\r\n    class MyMoon\r\n      include Id::Model\r\n\r\n      field :temperature\r\n    end\r\n\r\n    class Sun\r\n      include Id::Model\r\n      \r\n      field :temperature\r\n    end\r\n\r\n    class Earth\r\n      include Id::Model\r\n\r\n      has_one :sun\r\n      has_one :moon, key: \"satellite\", optional: true, type: MyMoon\r\n    end\r\n\r\n    earth = Earth.new(sun: {temperature: \"very very hot\"})\r\n    earth.sun.temperature # => \"very very hot\"\r\n    earth.sun.class # => Sun\r\n    earth.moon.some? # => false\r\n\r\n    earth_clone = Earth.new(sun: {temperature: \"quite hot\"}, satellite: { temperature: \"cold\" })\r\n    earth_clone.moon.some? # => true\r\n    earth_clone.moon.value.temperature # => \"cold\"\r\n    earth_clone.moon.value.class # => MyMoon\r\n\r\n\r\n#### has_many(field, options={})\r\n\r\ncreate new has_many \"association\" field\r\n\r\n##### options\r\n* _key_: fetch _key_ instead of field_name from data hash\r\n* _type_: change types of returned values\r\n\r\nExample:\r\n\r\n    class Satellite\r\n      include Id::Model\r\n\r\n      field :name\r\n    end\r\n\r\n    class Planet\r\n      include Id::Model\r\n\r\n      has_many :moons, type: Satellite\r\n      has_many :satellites, key: \"sputniks\"\r\n    end\r\n\r\n    earth = Planet.new(moons: [{name: \"moon\"}], sputniks: [{name: \"sputnik 1\"}])\r\n    earth.satellites.first.class # => Satellite\r\n    earth.satellites.first.name # => \"sputnik 1\"\r\n    earth.moons.first.class # => Satellite\r\n    earth.moons.first.name # => \"moon\" \r\n\r\n#### builder\r\n\r\nmodels can be built using a builder\r\n\r\nExample:\r\n\r\n    class Sun\r\n      include Id::Model\r\n      \r\n      field :color\r\n    end\r\n\r\n    class Moon\r\n      include Id::Model\r\n\r\n      field :color\r\n    end\r\n\r\n    class Planet\r\n      include Id::Model\r\n\r\n      field :name\r\n      has_many :moons\r\n      has_one :star\r\n    end\r\n    \r\n    sun = Sun.builder.color(\"yellow\").build\r\n    sun.color # => \"yellow\"\r\n    sun.class # => Sun\r\n\r\n    moon = Moon.builder.color(\"grey\").build\r\n    earth = Planet.builder.star(sun).moons([moon]).name(\"earth\")\r\n    earth.sun.color # => \"yellow\"\r\n    earth.moons.first.color # => \"grey\"\r\n    earth.name # => \"earth\"\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}